<!DOCTYPE html>
<meta charset="utf-8">
<style>


#header h1 {
  top: 10px;
  left: 10px;
  width: 800px;
  position: absolute;
  color: white;
}

#svgdiv-mx {
  float: left;
  width: 550px;
  height: 850px;
  margin: 10px 20px 10px 20px;
  color: white;
  mix-blend-mode: multiply;
}

#svg-mx {
  align-items: center;
  margin: auto;
  position: relative;
  display: block;
}

#options {
  float:left;
  position: relative;
  margin-left: 600px;
}

.inter-layer {
  stroke: gray;
  stroke-width: 0.5px;
  mix-blend-mode: lighten;
}

.intra-layer {
  stroke: gray;
  stroke-width: 1px;
  mix-blend-mode: color-dodge;
}

.boxes {
  fill-opacity: 0.1;
  stroke-width: 3;
  mix-blend-mode: lighten;
  stroke-opacity: 0.5;
}

.nodes_circles {
  stroke: none;
}

.nodes_strokes {
  stroke: gray;
  stroke-width: 1.5;
  fill: none;
  mix-blend-mode: lighten;
}

text {
  font-family: "Helvetica Neue", Helvetica, sans-serif;
  font-weight: lighter;
  color: white;
  font-size: 21px;
}

</style>


<body bgcolor=#0e1921>

<div id="header">
  <h1> Multilayer network </h1>
</div>



<div id="svgdiv-mx">
  <svg width="500" height="800" id="svg-mx"></svg>
</div>


<div id="options" width=100 height=200>
  Color nodes by:
  <select id="color-dropdown" title="Node color">
  <option value="name">Name</option>
  </select>

  <button type="button" id="mx-button">Save mx</button>

  Rotate mx:
  <button type="button" id="rotate-button">Rotate</button>



</div>





<!-- Load d3 and other helper scripts -->
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.6.0/d3.min.js"></script>
<script src="d3-save-svg-gh-pages/assets/d3-save-svg.min.js"></script>
<script src="https://unpkg.com/d3-3d/build/d3-3d.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>

<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>



<!-- begin javascript -->
<script>


// This file originally modified from https://bl.ocks.org/heybignick/3faf257bbbbc7743bb72310d03b86ee8
var svgmx= d3.select("#svg-mx"),
    widthmx = +svgmx.attr("width"),
    heightmx = +svgmx.attr("height");


svgmx.attr("class", "svg_class")


d3.json("data/mx_slide10_test.json", function(error, graph) {
  if (error) throw error;


  // need to know how many nodes in layer 1
  var nNodes = 17

  // Get coordinates of the first layer of nodes
  x_pos = [];
  y_pos = [];
  for (i = 0; i < nNodes; i++) {
    x_pos.push(graph.nodes[i].x);
    y_pos.push(graph.nodes[i].y)
  }

  // Define the center of our box

  const arrAvg = arr => arr.reduce((a,b) => a + b, 0) / arr.length
  box_center=[arrAvg(x_pos), arrAvg(y_pos)]

  // find the max x or y distance from box_center to any point
  var diffs = [];
  for (i=0; i < nNodes; i++) {
    diffs.push(Math.abs(box_center[0] - graph.nodes[i].x))
    diffs.push(Math.abs(box_center[1] - graph.nodes[i].y))
  }
  box_radius = Math.max(...diffs)


  // Set the box buffer
  var box_buffer = 0.15;

  // Projection functions

  function project_x(x_coord, y_coord, z_coord, d_project) {
    // x_proj = x_coord*Math.cos(2*Math.PI*(alpha/360)) // cos takes radians
    // first from python to 3d using OP
    x_3d = y_coord;
    z_3d = x_coord + d_project;
    x_0 = 15;

    // next project from 3d to 2d window
    x_proj = x_0 + (x_3d-x_0)*(d_project/z_3d)
    return x_proj
  }

  function project_y(x_coord, y_coord, z_coord, d_project) {
    // y_proj = y_coord*Math.sin(2*Math.PI*(alpha/360)) + l_v;
    // first from python to 3d using //
    y_3d = z_coord;
    z_3d = x_coord + d_project;
    y_0 = -2;

    // next project from 3d to 2d
    y_proj = (-1)*(y_0 + (y_3d-y_0)*(d_project/z_3d))

    return y_proj
  }

  var d_project = 1, l_v = 1
  // Define box path
  function box_path(box_center, box_radius, box_buffer, layer) {

    // need to project, then scale the projection
        console.log(layer)
        var z_value = graph.nodes.filter(function(n){return n.L2 == layer;})[0].z
        console.log(graph.nodes.filter(function(n){return n.L2 == layer;})[0])

        const x1p = x_scale(project_x(box_center[0] - box_radius - box_buffer, box_center[1] + box_radius + box_buffer, z_value, d_project));
        const y1p = y_scale(project_y(box_center[0] - box_radius - box_buffer, box_center[1] + box_radius + box_buffer, z_value, d_project));
        const x2p = x_scale(project_x(box_center[0] + box_radius + box_buffer, box_center[1] + box_radius + box_buffer, z_value, d_project));
        const y2p = y_scale(project_y(box_center[0] + box_radius + box_buffer, box_center[1] + box_radius + box_buffer, z_value, d_project));
        const x3p = x_scale(project_x(box_center[0] + box_radius + box_buffer, box_center[1] - box_radius - box_buffer, z_value, d_project));
        const y3p = y_scale(project_y(box_center[0] + box_radius + box_buffer, box_center[1] - box_radius - box_buffer, z_value, d_project));
        const x4p = x_scale(project_x(box_center[0] - box_radius - box_buffer, box_center[1] - box_radius - box_buffer, z_value, d_project));
        const y4p = y_scale(project_y(box_center[0] - box_radius - box_buffer, box_center[1] - box_radius - box_buffer, z_value, d_project));
        //
        // const x1 = 2
        // const x2 = 8
        // const y1 = 10
        // const y2=20

        return `M ${x1p},${y1p} L ${x2p},${y2p} L ${x3p} ${y3p} L ${x4p} ${y4p} L ${x1p} ${y1p}`;
      }

// Define necessary functions for nodes


  var node_radius = 7;


  var y_scale = d3.scaleLinear()
    .range([150, heightmx-150])

  y_scale.domain(d3.extent(graph.nodes, function(d) {return project_y(d.x, d.y, d.z, d_project); }));

  console.log(d3.extent(graph.nodes, function(d) {return project_x(d.x, d.y, d.z, d_project); }))
  console.log(project_x(box_center[0] - box_radius - box_buffer, box_center[1] + box_radius + box_buffer, 3, d_project))
  console.log(box_center)
  var x_scale = d3.scaleLinear()
    .range([80, widthmx-80])

  x_scale.domain(d3.extent(graph.nodes, function(d) {return project_x(d.x, d.y, d.z, d_project); }));

  var node_colormap = d3.scaleOrdinal(d3.schemeDark2).domain(d3.extent(graph.nodes, function(d) {return d.L2}));

  d3.select("#color-dropdown").text("first");

  layer_data = Object.getOwnPropertyNames(graph.nodes[0])
  d3.select("#color-dropdown").selectAll("option")
    .data(layer_data)
    .enter()
      .append("option")
        .attr("value", function(d) {return d})
        .text(function(d) {return d});

// functions and info for edges
  function edge_line(d) {
        const source_node = graph.nodes.filter(function(n){return n.id == d.source;})[0]
        const target_node = graph.nodes.filter(function(n){return n.id == d.target;})[0]
        const y1 = y_scale(project_y(source_node.x, source_node.y, source_node.z, d_project));
        const x1 = x_scale(project_x(source_node.x, source_node.y, source_node.z, d_project));
        const y2 = y_scale(project_y(target_node.x, target_node.y, target_node.z, d_project));
        const x2 = x_scale(project_x(target_node.x, target_node.y, target_node.z, d_project));
        console.log(source_node.z)
        return `M ${x1},${y1} L ${x2},${y2}`;
      }

  function edge_class(d) {
    // Determine within layer or between layer edges
    node_source_L2 = graph.nodes.filter(function(n){return n.id == d.source;})[0].L2
    node_target_L2 = graph.nodes.filter(function(n){return n.id == d.target;})[0].L2

    if (node_source_L2 == node_target_L2) {
      edge_class_id = "intra-layer"
    } else {
      edge_class_id = "inter-layer"
    }

    return edge_class_id
  }

  var link = svgmx.append("g")
    .selectAll("line")
    .data(graph.links)
    .enter().append("path")
      .attr("d", edge_line)
      .attr("class", edge_class);




  var node = svgmx.append("g")
    .attr("class","nodes")
    .selectAll("g")
    .data(graph.nodes)
    .enter().append("g")


  node.append("circle")
    .attr("r", node_radius)
    .attr("cx", function(d) {return x_scale(project_x(d.x, d.y, d.z, d_project))})
    .attr("cy", function(d) {return y_scale(project_y(d.x, d.y, d.z, d_project))})
    .attr("fill", function(d) {return node_colormap(d.L2)})
    .attr("class", "nodes_circles")
    .attr("id", function(d) {return d.id})

  node.append("circle")
    .attr("r", node_radius)
    .attr("cx", function(d) {return x_scale(project_x(d.x, d.y, d.z, d_project))})
    .attr("cy", function(d) {return y_scale(project_y(d.x, d.y, d.z, d_project))})
    .attr("class", "nodes_strokes")
    .attr("id", function(d) {return d.id})



  var boxes = svgmx.append("g")

  var nLayers = 5;
  for (i=0; i<nLayers; i++) {
    boxes.append("path")
      .attr("d",box_path(box_center, box_radius, box_buffer, i))
      .attr("class", "boxes")
      .attr("fill", function(d) {return node_colormap(graph.nodes.filter(function(n){return n.L2 == i;})[0].L2)})
      .attr("stroke", function(d) {return node_colormap(graph.nodes.filter(function(n){return n.L2 == i;})[0].L2)})
    }


// buttons!
  d3.select('#mx-button').on('click', function() {
    var config = {
      filename: 'mx',
    }
    d3_save_svg.save(d3.select('#svg-mx').node(), config);
  });

  d3.select("#rotate-button").on("click", function() {
    d3.select("#svg-mx")
      .attr("transform", "rotate(90)");
  })



});


</script>
