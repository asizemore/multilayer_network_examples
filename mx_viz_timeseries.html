<!DOCTYPE html>
<meta charset="utf-8">
<style>


#header h1 {
  top: 10px;
  left: 10px;
  width: 800px;
  position: absolute;
  color: white;
}

#svgdiv-mx {
  float: left;
  margin: 10px 20px 10px 20px;
  color: white;
  mix-blend-mode: multiply;
}

#svg-mx {
  align-items: center;
  margin: auto;
  position: relative;
  display: block;
}

#options {
  float:left;
  position: relative;
  margin-left: 600px;
}

.inter-layer {
  stroke: gray;
  stroke-width: 0.5px;
  mix-blend-mode: lighten;
}

.intra-layer {
  stroke: gray;
  stroke-width: 1px;
  mix-blend-mode: color-dodge;
}

.boxes {
  fill-opacity: 0.1;
  stroke-width: 3;
  mix-blend-mode: hard-light;
  stroke-opacity: 0.5;
}

.nodes_circles {
  stroke: none;
}

.nodes_strokes {
  stroke: gray;
  stroke-width: 1.5;
  fill: none;
  mix-blend-mode: lighten;
}

text {
  font-family: "Helvetica Neue", Helvetica, sans-serif;
  font-weight: lighter;
  color: white;
  font-size: 21px;
}

</style>


<body bgcolor=#ffffff>

<div id="header">
  <h1> Multilayer network </h1>
</div>



<div id="svgdiv-mx">
  <svg width="1800" height="600" id="svg-mx"></svg>
</div>


<div id="options" width=100 height=200>
  Color nodes by:
  <select id="color-dropdown" title="Node color">
  <option value="name">Name</option>
  </select>

  <button type="button" id="mx-button">Save mx</button>

  Rotate mx:
  <button type="button" id="rotate-button">Rotate</button>

  Slider:
  <!-- Add a slider -->
  <input type="range" name="x0 Slider" id="slider-x0" min="-20" max="0" value="10">

  Slider:
  <!-- Add a slider -->
  <input type="range" name="y0 Slider" id="slider-y0" min="-40" max="-0.1" value="-5">





</div>





<!-- Load d3 and other helper scripts -->
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.6.0/d3.min.js"></script>
<script src="d3-save-svg-gh-pages/assets/d3-save-svg.min.js"></script>
<script src="https://unpkg.com/d3-3d/build/d3-3d.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>

<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>



<!-- begin javascript -->
<script>


// This file originally modified from https://bl.ocks.org/heybignick/3faf257bbbbc7743bb72310d03b86ee8
var svgmx= d3.select("#svg-mx"),
    widthmx = +svgmx.attr("width"),
    heightmx = +svgmx.attr("height");


svgmx.attr("class", "svg_class")


d3.json("data/mx_slide11_test.json", function(error, graph) {
  if (error) throw error;


  // need to know how many nodes in layer 1
  // Would be better to get the number of unique values in L1 ...
  var nodes_in_L1 = d3.extent(graph.nodes, function(d) {return d.L1})
  console.log(nodes_in_L1)
  var nNodes = nodes_in_L1[1]+1;
  console.log(graph.nodes)

  // Get number of layers
  // Would be better to get the number of unique values in L2.
  var nLayers = d3.extent(graph.nodes, function(d) {return d.L2})[1]+1

  // Get coordinates of the first layer of nodes
  x_pos = [];
  y_pos = [];
  console.log(nNodes)
  for (i = 0; i < nNodes; i++) {
    x_pos.push(graph.nodes[i].x);
    y_pos.push(graph.nodes[i].y)
  }

  // Define the center of our box

  const arrAvg = arr => arr.reduce((a,b) => a + b, 0) / arr.length
  box_center=[arrAvg(x_pos), arrAvg(y_pos)]

  // find the max x and y distances from box_center to any point
  var diffsx = [];
  var diffsy = [];
  for (i=0; i < nNodes; i++) {
    diffsx.push(Math.abs(box_center[0] - graph.nodes[i].x))
    diffsy.push(Math.abs(box_center[1] - graph.nodes[i].y))
  }
  box_radiusx = Math.max(...diffsx)
  box_radiusy = Math.max(...diffsy)


  // Set the box buffer
  var box_buffer = 0.15;

  // Projection functions
  var x_0 = 10;
  var y_0 = -5;


  function project_x(x_coord, y_coord, z_coord, d_project, x_0) {
    // x_proj = x_coord*Math.cos(2*Math.PI*(alpha/360)) // cos takes radians
    // first from python to 3d using OP
    x_3d = z_coord;
    z_3d = y_coord + d_project;

    // next project from 3d to 2d window
    x_proj = x_0 + (x_3d-x_0)*(d_project/z_3d)
    return x_proj
  }

  function project_y(x_coord, y_coord, z_coord, d_project, y_0) {
    // y_proj = y_coord*Math.sin(2*Math.PI*(alpha/360)) + l_v;
    // first from python to 3d using //
    y_3d = x_coord;
    z_3d = y_coord + d_project;

    // next project from 3d to 2d
    y_proj = (-1)*(y_0 + (y_3d-y_0)*(d_project/z_3d))

    return y_proj
  }

  var d_project = 1, l_v = 1
  // Define box path
  function box_path(box_center, box_radiusx, box_radiusy, box_buffer, layer, x_0, y_0, d_project) {

    // need to project, then scale the projection
        var z_value = graph.nodes.filter(function(n){return n.L2 == layer;})[0].z


        const x1p = x_scale(project_x(box_center[0] - box_radiusx - box_buffer, box_center[1] + box_radiusy + box_buffer, z_value, d_project, x_0));
        const y1p = y_scale(project_y(box_center[0] - box_radiusx - box_buffer, box_center[1] + box_radiusy + box_buffer, z_value, d_project, y_0));
        const x2p = x_scale(project_x(box_center[0] + box_radiusx + box_buffer, box_center[1] + box_radiusy + box_buffer, z_value, d_project, x_0));
        const y2p = y_scale(project_y(box_center[0] + box_radiusx + box_buffer, box_center[1] + box_radiusy + box_buffer, z_value, d_project, y_0));
        const x3p = x_scale(project_x(box_center[0] + box_radiusx + box_buffer, box_center[1] - box_radiusy - box_buffer, z_value, d_project, x_0));
        const y3p = y_scale(project_y(box_center[0] + box_radiusx + box_buffer, box_center[1] - box_radiusy - box_buffer, z_value, d_project, y_0));
        const x4p = x_scale(project_x(box_center[0] - box_radiusx - box_buffer, box_center[1] - box_radiusy - box_buffer, z_value, d_project, x_0));
        const y4p = y_scale(project_y(box_center[0] - box_radiusx - box_buffer, box_center[1] - box_radiusy - box_buffer, z_value, d_project, y_0));
        //
        // const x1 = 2
        // const x2 = 8
        // const y1 = 10
        // const y2=20

        return `M ${x1p},${y1p} L ${x2p},${y2p} L ${x3p} ${y3p} L ${x4p} ${y4p} L ${x1p} ${y1p}`;
      }

// Define necessary functions for nodes


  var node_radius = 6;


  var y_scale = d3.scaleLinear()
    .range([150, heightmx-150])

  y_scale.domain(d3.extent(graph.nodes, function(d) {return project_y(d.x, d.y, d.z, d_project, y_0); }));


  var x_scale = d3.scaleLinear()
    .range([150, widthmx-150])

  x_scale.domain(d3.extent(graph.nodes, function(d) {return project_x(d.x, d.y, d.z, d_project, x_0); }));

  var node_colormap = d3.scaleSequential(d3.interpolateRdYlBu).domain(d3.extent(graph.nodes, function(d) {return d.L2}));

  d3.select("#color-dropdown").text("first");

  layer_data = Object.getOwnPropertyNames(graph.nodes[0])
  d3.select("#color-dropdown").selectAll("option")
    .data(layer_data)
    .enter()
      .append("option")
        .attr("value", function(d) {return d})
        .text(function(d) {return d});

// functions and info for edges
  function edge_line(d, x_0, y_0, d_project) {
        const source_node = graph.nodes.filter(function(n){return n.id == d.source;})[0]
        const target_node = graph.nodes.filter(function(n){return n.id == d.target;})[0]
        const y1 = y_scale(project_y(source_node.x, source_node.y, source_node.z, d_project, y_0));
        const x1 = x_scale(project_x(source_node.x, source_node.y, source_node.z, d_project, x_0));
        const y2 = y_scale(project_y(target_node.x, target_node.y, target_node.z, d_project, y_0));
        const x2 = x_scale(project_x(target_node.x, target_node.y, target_node.z, d_project, x_0));

        return `M ${x1},${y1} L ${x2},${y2}`;
      }

  function edge_class(d) {
    // Determine within layer or between layer edges
    node_source_L2 = graph.nodes.filter(function(n){return n.id == d.source;})[0].L2
    node_target_L2 = graph.nodes.filter(function(n){return n.id == d.target;})[0].L2

    if (node_source_L2 == node_target_L2) {
      edge_class_id = "intra-layer"
    } else {
      edge_class_id = "inter-layer"
    }

    return edge_class_id
  }

  var link = svgmx.append("g")
    .selectAll("line")
    .data(graph.links)
    .enter().append("path")
      .attr("d", function(d) {return edge_line(d,x_0, y_0, d_project)})
      .attr("class", edge_class);




  var node = svgmx.append("g")
    .attr("class","nodes")
    .selectAll("g")
    .data(graph.nodes)
    .enter().append("g")


  node.append("circle")
    .attr("r", node_radius)
    .attr("cx", function(d) {return x_scale(project_x(d.x, d.y, d.z, d_project, x_0))})
    .attr("cy", function(d) {return y_scale(project_y(d.x, d.y, d.z, d_project, y_0))})
    .attr("fill", function(d) {return node_colormap(d.L2)})
    .attr("class", "nodes_circles")
    .attr("id", function(d) {return d.id})

  node.append("circle")
    .attr("r", node_radius)
    .attr("cx", function(d) {return x_scale(project_x(d.x, d.y, d.z, d_project, x_0))})
    .attr("cy", function(d) {return y_scale(project_y(d.x, d.y, d.z, d_project, y_0))})
    .attr("class", "nodes_strokes")
    .attr("id", function(d) {return d.id})



  var boxes = svgmx.append("g")

  // Can create an array of layers and then attach that data instead
  // of using a for loop
  for (i=0; i<nLayers; i++) {
    boxes.append("path")
      .attr("d",box_path(box_center, box_radiusx, box_radiusy, box_buffer, i, x_0, y_0, d_project))
      .attr("class", "boxes")
      .attr("id", `box${i}`)
      .attr("fill", function(d) {return node_colormap(graph.nodes.filter(function(n){return n.L2 == i;})[0].L2)})
      .attr("stroke", function(d) {return node_colormap(graph.nodes.filter(function(n){return n.L2 == i;})[0].L2)})
    }




// buttons!
  d3.select('#mx-button').on('click', function() {
    var config = {
      filename: 'mx',
    }
    d3_save_svg.save(d3.select('#svg-mx').node(), config);
  });

  d3.select("#rotate-button").on("click", function() {
    d3.select("#svg-mx")
      .attr("transform", "rotate(90)");
  })

  // Slider functions
  function changex0(selectedValuex, selectedValuey, selected_value_d) {
    x_0 = selectedValuex;
    y_0 = selectedValuey;
    d_project = selected_value_d;
    console.log(x_0)
    console.log(y_0)
    // Need to recalculate the x_scale domain each time
    x_scale.domain(d3.extent(graph.nodes, function(d) {return project_x(d.x, d.y, d.z, d_project, x_0); }));

    // And y scale
    y_scale.domain(d3.extent(graph.nodes, function(d) {return project_y(d.x, d.y, d.z, d_project, y_0); }));

    // Recalculate node position
    d3.selectAll(".nodes_circles")
      .attr("cx", function(d) {return x_scale(project_x(d.x, d.y, d.z, d_project, x_0))})
      .attr("cy", function(d) {return y_scale(project_y(d.x, d.y, d.z, d_project, y_0))})

    d3.selectAll(".nodes_strokes")
      .attr("cx", function(d) {return x_scale(project_x(d.x, d.y, d.z, d_project, x_0))})
      .attr("cy", function(d) {return y_scale(project_y(d.x, d.y, d.z, d_project, y_0))})

    // Recalculate edge postitions
    d3.selectAll(".intra-layer")
      .attr("d", function(d) {return edge_line(d,x_0, y_0, d_project)});

    d3.selectAll(".inter-layer")
      .attr("d", function(d) {return edge_line(d,x_0, y_0, d_project)});

    // Recalculate box postitions
    for (i=0; i<nLayers; i++) {
      d3.selectAll(`#box${i}`)
        .attr("d",function(d) {return box_path(box_center, box_radiusx, box_radiusy, box_buffer, i, x_0, y_0, d_project)})
        .attr("fill", function(d) {return node_colormap(graph.nodes.filter(function(n){return n.L2 == i;})[0].L2)})
        .attr("stroke", function(d) { return node_colormap(graph.nodes.filter(function(n){return n.L2 == i;})[0].L2)})
    }




  }

  // Listen to the slider?
  d3.select("#slider-x0").on("change", function(d){
    selectedValue = this.value
    changex0(selectedValue, y_0, d_project)

  })

  d3.select("#slider-y0").on("change", function(d){
    selectedValue = this.value
    changex0(x_0, selectedValue, d_project)

  })





});


</script>
